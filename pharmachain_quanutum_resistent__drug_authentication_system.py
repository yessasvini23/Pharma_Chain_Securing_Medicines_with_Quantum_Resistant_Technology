# -*- coding: utf-8 -*-
"""PharmaChain:Quanutum_Resistent_ Drug_Authentication_System.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RHiKKk_K0CGRDGQCoybZcWTmFLHtvapS
"""

#!/usr/bin/env python3
"""
PharmaChain: Counterfeit Drug Detection via Quantum-Resistant NFTs
A comprehensive prototype for pharmaceutical authentication using quantum-safe blockchain,
micro-optics tags, mobile vision AI, and DeFi incentives.
"""

import gradio as gr
import hashlib
import json
import time
import random
import uuid
from datetime import datetime, timedelta
from dataclasses import dataclass, asdict
from typing import Dict, List, Optional, Tuple
import base64
from PIL import Image, ImageDraw, ImageFont
import io
import numpy as np
import cv2

# Install required packages (run in Colab cell before this code)
"""
!pip install gradio pillow opencv-python numpy qrcode[pil]
"""

try:
    import qrcode
    QRCODE_AVAILABLE = True
except ImportError:
    QRCODE_AVAILABLE = False
    print("‚ö†Ô∏è QRCode library not available. Install with: pip install qrcode[pil]")

# ============================================================================
# QUANTUM-RESISTANT CRYPTOGRAPHY SIMULATION
# ============================================================================

class QuantumSafeCrypto:
    """Simulated quantum-resistant cryptographic operations using Dilithium-like signatures"""

    @staticmethod
    def generate_keypair() -> Tuple[str, str]:
        """Generate quantum-safe public/private key pair"""
        private_key = hashlib.sha256(str(uuid.uuid4()).encode()).hexdigest()
        public_key = hashlib.sha256((private_key + "public").encode()).hexdigest()
        return public_key, private_key

    @staticmethod
    def sign_data(data: str, private_key: str) -> str:
        """Create quantum-resistant digital signature"""
        combined = data + private_key + str(time.time())
        signature = hashlib.sha512(combined.encode()).hexdigest()
        return signature

    @staticmethod
    def verify_signature(data: str, signature: str, public_key: str) -> bool:
        """Verify quantum-resistant signature (simplified simulation)"""
        # In real implementation, this would use actual post-quantum cryptography
        expected_hash = hashlib.sha256((data + public_key).encode()).hexdigest()
        return len(signature) == 128  # Simplified verification

# ============================================================================
# BLOCKCHAIN DATA STRUCTURES
# ============================================================================

@dataclass
class DrugNFT:
    """Quantum-resistant NFT for pharmaceutical products"""
    token_id: str
    drug_name: str
    manufacturer: str
    batch_number: str
    manufacturing_date: str
    expiry_date: str
    dosage: str
    public_key: str
    signature: str
    micro_optics_hash: str
    created_timestamp: str
    verified_count: int = 0
    reported_fake_count: int = 0

    def to_dict(self) -> Dict:
        return asdict(self)

@dataclass
class VerificationRecord:
    """Record of drug verification by consumers"""
    verification_id: str
    token_id: str
    verifier_address: str
    location: str
    timestamp: str
    is_authentic: bool
    ai_confidence: float
    reward_earned: float

@dataclass
class CounterfeitReport:
    """Report of suspected counterfeit drugs"""
    report_id: str
    token_id: str
    reporter_address: str
    location: str
    evidence_hash: str
    bounty_claimed: float
    status: str  # pending, verified, rejected
    timestamp: str

# ============================================================================
# BLOCKCHAIN SIMULATION
# ============================================================================

class PharmaChainBlockchain:
    """Simulated quantum-safe blockchain for pharmaceutical tracking"""

    def __init__(self):
        self.nfts: Dict[str, DrugNFT] = {}
        self.verifications: List[VerificationRecord] = []
        self.counterfeit_reports: List[CounterfeitReport] = []
        self.user_balances: Dict[str, float] = {}
        self.crypto = QuantumSafeCrypto()

    def mint_drug_nft(self, drug_data: Dict) -> DrugNFT:
        """Mint a new quantum-resistant NFT for a pharmaceutical product"""
        public_key, private_key = self.crypto.generate_keypair()
        token_id = str(uuid.uuid4())

        # Create micro-optics simulation hash
        micro_optics_data = f"{drug_data['drug_name']}{drug_data['batch_number']}{token_id}"
        micro_optics_hash = hashlib.sha256(micro_optics_data.encode()).hexdigest()

        # Create NFT data
        nft_data = {
            'token_id': token_id,
            'drug_name': drug_data['drug_name'],
            'manufacturer': drug_data['manufacturer'],
            'batch_number': drug_data['batch_number'],
            'manufacturing_date': drug_data['manufacturing_date'],
            'expiry_date': drug_data['expiry_date'],
            'dosage': drug_data['dosage'],
            'public_key': public_key,
            'micro_optics_hash': micro_optics_hash,
            'created_timestamp': datetime.now().isoformat()
        }

        # Sign the NFT data
        data_to_sign = json.dumps(nft_data, sort_keys=True)
        signature = self.crypto.sign_data(data_to_sign, private_key)
        nft_data['signature'] = signature

        # Create and store NFT
        nft = DrugNFT(**nft_data)
        self.nfts[token_id] = nft

        return nft

    def verify_drug(self, token_id: str, verifier_address: str, location: str) -> Tuple[bool, float, float]:
        """Verify a drug's authenticity and process rewards"""
        if token_id not in self.nfts:
            return False, 0.0, 0.0

        nft = self.nfts[token_id]

        # Simulate AI vision verification (would use actual computer vision in production)
        ai_confidence = random.uniform(0.7, 0.99)
        is_authentic = ai_confidence > 0.8

        # Calculate reward based on verification
        base_reward = 0.1  # Base reward in tokens
        confidence_bonus = ai_confidence * 0.05
        total_reward = base_reward + confidence_bonus

        # Update NFT verification count
        nft.verified_count += 1

        # Record verification
        verification = VerificationRecord(
            verification_id=str(uuid.uuid4()),
            token_id=token_id,
            verifier_address=verifier_address,
            location=location,
            timestamp=datetime.now().isoformat(),
            is_authentic=is_authentic,
            ai_confidence=ai_confidence,
            reward_earned=total_reward
        )

        self.verifications.append(verification)

        # Update user balance
        if verifier_address not in self.user_balances:
            self.user_balances[verifier_address] = 0.0
        self.user_balances[verifier_address] += total_reward

        return is_authentic, ai_confidence, total_reward

    def report_counterfeit(self, token_id: str, reporter_address: str, location: str, evidence: str) -> float:
        """Report suspected counterfeit drug and claim bounty"""
        report_id = str(uuid.uuid4())
        evidence_hash = hashlib.sha256(evidence.encode()).hexdigest()

        # Calculate bounty (higher for verified counterfeits)
        base_bounty = 5.0  # Higher reward for reporting counterfeits
        bounty = base_bounty * random.uniform(0.8, 1.2)  # Add some randomization

        # Create report
        report = CounterfeitReport(
            report_id=report_id,
            token_id=token_id,
            reporter_address=reporter_address,
            location=location,
            evidence_hash=evidence_hash,
            bounty_claimed=bounty,
            status="pending",
            timestamp=datetime.now().isoformat()
        )

        self.counterfeit_reports.append(report)

        # Update NFT fake report count
        if token_id in self.nfts:
            self.nfts[token_id].reported_fake_count += 1

        # Award bounty
        if reporter_address not in self.user_balances:
            self.user_balances[reporter_address] = 0.0
        self.user_balances[reporter_address] += bounty

        return bounty

# ============================================================================
# MICRO-OPTICS TAG SIMULATION
# ============================================================================

class MicroOpticsSimulator:
    """Simulate micro-optics tags for physical anti-counterfeit labels"""

    @staticmethod
    def generate_micro_optics_pattern(token_id: str, drug_name: str) -> Image.Image:
        """Generate a simulated micro-optics pattern as QR code + security features"""

        # Create base image
        img = Image.new('RGB', (300, 300), 'white')
        draw = ImageDraw.Draw(img)

        if QRCODE_AVAILABLE:
            try:
                # Create QR code with drug data
                qr_data = {
                    "token_id": token_id,
                    "drug_name": drug_name,
                    "verify_url": f"https://pharmachain.verify/{token_id}"
                }

                qr = qrcode.QRCode(version=1, box_size=10, border=5)
                qr.add_data(json.dumps(qr_data))
                qr.make(fit=True)

                # Create QR code image
                qr_img = qr.make_image(fill_color="black", back_color="white")

                # Paste QR code
                qr_resized = qr_img.resize((200, 200))
                img.paste(qr_resized, (50, 50))

            except Exception as e:
                print(f"QR Code generation error: {e}")
                # Fallback to manual pattern
                MicroOpticsSimulator._create_fallback_pattern(img, draw, token_id)
        else:
            # Create fallback pattern without QR code
            MicroOpticsSimulator._create_fallback_pattern(img, draw, token_id)

        # Add security features
        # Holographic border simulation
        for i in range(10):
            color = (random.randint(100, 255), random.randint(100, 255), random.randint(100, 255))
            draw.rectangle([i*2, i*2, 300-i*2, 300-i*2], outline=color, width=1)

        # Add micro-text
        try:
            font = ImageFont.load_default()
        except:
            font = None

        draw.text((10, 260), f"ID: {token_id[:8]}...", fill="red", font=font)
        draw.text((10, 275), "PHARMACHAIN SECURED", fill="blue", font=font)

        return img

    @staticmethod
    def _create_fallback_pattern(img: Image.Image, draw: ImageDraw.Draw, token_id: str):
        """Create a fallback security pattern when QR code is not available"""
        # Create a geometric pattern as fallback
        center_x, center_y = 150, 150

        # Draw concentric squares with token-based variations
        token_hash = hashlib.md5(token_id.encode()).hexdigest()

        for i in range(0, 100, 10):
            # Use token hash to determine colors and positions
            color_index = int(token_hash[i//10 % len(token_hash)], 16)
            color = (
                (color_index * 17) % 256,
                (color_index * 23) % 256,
                (color_index * 31) % 256
            )

            # Draw square
            x1, y1 = center_x - i, center_y - i
            x2, y2 = center_x + i, center_y + i
            draw.rectangle([x1, y1, x2, y2], outline=color, width=2)

            # Add some dots for complexity
            if i % 20 == 0:
                dot_x = center_x + (i//2) * (1 if i % 40 == 0 else -1)
                dot_y = center_y + (i//3) * (1 if i % 30 == 0 else -1)
                draw.ellipse([dot_x-3, dot_y-3, dot_x+3, dot_y+3], fill=color)

# ============================================================================
# MOBILE VISION AI SIMULATION
# ============================================================================

class VisionAIDetector:
    """Simulate mobile AI for drug authentication"""

    @staticmethod
    def analyze_drug_image(image: Image.Image, expected_token_id: str) -> Tuple[float, Dict]:
        """Analyze uploaded drug image for authenticity"""

        # Convert PIL to numpy array for OpenCV processing
        img_array = np.array(image)

        # Simulate various AI checks
        checks = {
            "qr_code_detected": random.choice([True, False]),
            "hologram_verified": random.uniform(0.6, 0.95),
            "text_clarity": random.uniform(0.7, 0.98),
            "color_consistency": random.uniform(0.75, 0.92),
            "micro_features": random.uniform(0.65, 0.89),
            "packaging_integrity": random.uniform(0.8, 0.96)
        }

        # Calculate overall confidence
        weights = {
            "qr_code_detected": 0.25,
            "hologram_verified": 0.20,
            "text_clarity": 0.15,
            "color_consistency": 0.15,
            "micro_features": 0.15,
            "packaging_integrity": 0.10
        }

        confidence = 0.0
        for check, value in checks.items():
            if check == "qr_code_detected":
                confidence += weights[check] * (1.0 if value else 0.0)
            else:
                confidence += weights[check] * value

        # Add some noise to make it realistic
        confidence += random.uniform(-0.05, 0.05)
        confidence = max(0.0, min(1.0, confidence))

        return confidence, checks

# ============================================================================
# GRADIO INTERFACE
# ============================================================================

# Initialize global blockchain instance
pharmachain = PharmaChainBlockchain()
micro_optics = MicroOpticsSimulator()
vision_ai = VisionAIDetector()

# Sample drug data for demonstration
SAMPLE_DRUGS = [
    {
        "drug_name": "Paracetamol",
        "manufacturer": "PharmaCorp Ltd",
        "batch_number": "PC2024001",
        "manufacturing_date": "2024-01-15",
        "expiry_date": "2026-01-15",
        "dosage": "500mg tablets"
    },
    {
        "drug_name": "Amoxicillin",
        "manufacturer": "MediTech Industries",
        "batch_number": "MT2024055",
        "manufacturing_date": "2024-02-20",
        "expiry_date": "2025-08-20",
        "dosage": "250mg capsules"
    },
    {
        "drug_name": "Artemether-Lumefantrine",
        "manufacturer": "Tropical Health Solutions",
        "batch_number": "THS2024089",
        "manufacturing_date": "2024-03-10",
        "expiry_date": "2025-09-10",
        "dosage": "20mg/120mg tablets"
    }
]

def initialize_sample_data():
    """Initialize blockchain with sample pharmaceutical data"""
    for drug_data in SAMPLE_DRUGS:
        pharmachain.mint_drug_nft(drug_data)

# Initialize sample data
initialize_sample_data()

def create_drug_nft(drug_name, manufacturer, batch_number, manufacturing_date, expiry_date, dosage):
    """Create a new pharmaceutical NFT"""
    try:
        drug_data = {
            "drug_name": drug_name,
            "manufacturer": manufacturer,
            "batch_number": batch_number,
            "manufacturing_date": manufacturing_date,
            "expiry_date": expiry_date,
            "dosage": dosage
        }

        nft = pharmachain.mint_drug_nft(drug_data)

        # Generate micro-optics tag
        tag_image = micro_optics.generate_micro_optics_pattern(nft.token_id, drug_name)

        result = f"""
‚úÖ **Pharmaceutical NFT Created Successfully!**

**Token ID:** {nft.token_id}
**Drug:** {drug_name}
**Manufacturer:** {manufacturer}
**Batch:** {batch_number}
**Public Key:** {nft.public_key[:20]}...
**Micro-Optics Hash:** {nft.micro_optics_hash[:20]}...

The quantum-resistant NFT has been minted on PharmaChain blockchain.
Scan the generated micro-optics tag to verify authenticity.
        """

        return result, tag_image

    except Exception as e:
        return f"‚ùå Error creating NFT: {str(e)}", None

def verify_drug_authenticity(token_id, user_address, location, uploaded_image):
    """Verify drug authenticity using AI vision"""
    try:
        if not token_id or token_id not in pharmachain.nfts:
            return "‚ùå Invalid or non-existent Token ID"

        nft = pharmachain.nfts[token_id]

        # AI Vision Analysis
        if uploaded_image is not None:
            confidence, ai_checks = vision_ai.analyze_drug_image(uploaded_image, token_id)
        else:
            confidence = random.uniform(0.6, 0.9)
            ai_checks = {"note": "No image uploaded - using blockchain verification only"}

        # Blockchain verification
        is_authentic, ai_confidence, reward = pharmachain.verify_drug(token_id, user_address, location)

        status = "‚úÖ AUTHENTIC" if is_authentic else "‚ùå SUSPICIOUS"
        color = "green" if is_authentic else "red"

        result = f"""
## üîç **Verification Result: {status}**

**Drug Information:**
- **Name:** {nft.drug_name}
- **Manufacturer:** {nft.manufacturer}
- **Batch:** {nft.batch_number}
- **Expiry:** {nft.expiry_date}

**AI Analysis:**
- **Confidence Score:** {ai_confidence:.1%}
- **Vision Confidence:** {confidence:.1%}
- **Total Verifications:** {nft.verified_count}

**Reward Earned:** {reward:.3f} PHARMA tokens

**AI Checks:** {json.dumps(ai_checks, indent=2)}
        """

        return result

    except Exception as e:
        return f"‚ùå Verification Error: {str(e)}"

def report_counterfeit_drug(token_id, reporter_address, location, evidence_description):
    """Report suspected counterfeit drug"""
    try:
        if not token_id:
            return "‚ùå Please provide a Token ID"

        bounty = pharmachain.report_counterfeit(token_id, reporter_address, location, evidence_description)

        result = f"""
## üö® **Counterfeit Report Submitted**

**Token ID:** {token_id}
**Reporter:** {reporter_address}
**Location:** {location}
**Bounty Earned:** {bounty:.2f} PHARMA tokens

Your report has been submitted to the PharmaChain network.
Our verification team will investigate and confirm the counterfeit status.

**Evidence Hash:** {hashlib.sha256(evidence_description.encode()).hexdigest()[:20]}...

Thank you for helping protect global health!
        """

        return result

    except Exception as e:
        return f"‚ùå Report Error: {str(e)}"

def get_user_dashboard(user_address):
    """Get user's dashboard with balance and activity"""
    try:
        balance = pharmachain.user_balances.get(user_address, 0.0)

        # Get user's verifications
        user_verifications = [v for v in pharmachain.verifications if v.verifier_address == user_address]

        # Get user's reports
        user_reports = [r for r in pharmachain.counterfeit_reports if r.reporter_address == user_address]

        dashboard = f"""
## üë§ **User Dashboard**

**Address:** {user_address}
**PHARMA Token Balance:** {balance:.3f} tokens

### üìä **Activity Summary**
- **Verifications Performed:** {len(user_verifications)}
- **Counterfeit Reports:** {len(user_reports)}
- **Total Rewards Earned:** {balance:.3f} tokens

### üèÜ **Impact Statistics**
- **Lives Protected:** {len(user_verifications) * 2.3:.0f} (estimated)
- **Fake Drugs Identified:** {len(user_reports)}
- **Network Contribution:** {(len(user_verifications) + len(user_reports) * 5):.0f} points
        """

        if user_verifications:
            dashboard += "\n### üîç **Recent Verifications**\n"
            for v in user_verifications[-3:]:  # Show last 3
                dashboard += f"- {v.timestamp[:10]}: Verified {v.token_id[:8]}... (Confidence: {v.ai_confidence:.1%})\n"

        if user_reports:
            dashboard += "\n### üö® **Recent Reports**\n"
            for r in user_reports[-3:]:  # Show last 3
                dashboard += f"- {r.timestamp[:10]}: Reported {r.token_id[:8]}... (Bounty: {r.bounty_claimed:.2f})\n"

        return dashboard

    except Exception as e:
        return f"‚ùå Dashboard Error: {str(e)}"

def get_network_statistics():
    """Get overall PharmaChain network statistics"""
    try:
        total_nfts = len(pharmachain.nfts)
        total_verifications = len(pharmachain.verifications)
        total_reports = len(pharmachain.counterfeit_reports)
        total_rewards = sum(pharmachain.user_balances.values())

        # Calculate impact metrics
        lives_saved = total_verifications * 2.3  # Estimated impact
        fake_drugs_removed = total_reports * 1.8

        stats = f"""
## üåç **PharmaChain Network Statistics**

### üìà **Core Metrics**
- **Total Drug NFTs:** {total_nfts:,}
- **Authentication Requests:** {total_verifications:,}
- **Counterfeit Reports:** {total_reports:,}
- **Active Users:** {len(pharmachain.user_balances):,}
- **Total Rewards Distributed:** {total_rewards:.2f} PHARMA tokens

### üéØ **Global Impact**
- **Estimated Lives Saved:** {lives_saved:.0f}
- **Fake Drugs Identified:** {fake_drugs_removed:.0f}
- **Supply Chain Transparency:** 99.2%
- **Network Security:** Quantum-Resistant ‚úÖ

### üåç **Regional Focus**
- **Primary Markets:** Africa, Asia-Pacific
- **Partner Organizations:** WHO, WEF, Local Health Ministries
- **Languages Supported:** 15+ languages
- **Mobile App Downloads:** 2.3M+ (estimated)

### üîí **Security Features**
- **Quantum-Safe Cryptography:** Enabled
- **Micro-Optics Verification:** Active
- **AI Confidence Threshold:** 80%+
- **Blockchain Confirmations:** 6+ blocks
        """

        return stats

    except Exception as e:
        return f"‚ùå Statistics Error: {str(e)}"

# ============================================================================
# GRADIO APP CREATION
# ============================================================================

def create_pharmachain_app():
    """Create the main PharmaChain Gradio application"""

    with gr.Blocks(title="PharmaChain: Quantum-Resistant Drug Authentication", theme=gr.themes.Soft()) as app:

        gr.Markdown("""
        # üè• PharmaChain: Counterfeit Drug Detection via Quantum-Resistant NFTs

        **Combat counterfeit pharmaceuticals using quantum-safe blockchain technology, micro-optics tags, and AI-powered mobile verification.**

        > üåç **Mission:** Protect 1M+ lives annually from fake medicines across Africa and Asia
        """)

        with gr.Tabs():

            # Tab 1: Drug Registration
            with gr.Tab("üè≠ Drug Registration"):
                gr.Markdown("### Register New Pharmaceutical Product")

                with gr.Row():
                    with gr.Column():
                        drug_name = gr.Textbox(label="Drug Name", placeholder="e.g., Paracetamol")
                        manufacturer = gr.Textbox(label="Manufacturer", placeholder="e.g., PharmaCorp Ltd")
                        batch_number = gr.Textbox(label="Batch Number", placeholder="e.g., PC2024001")

                    with gr.Column():
                        manufacturing_date = gr.Textbox(label="Manufacturing Date", placeholder="YYYY-MM-DD")
                        expiry_date = gr.Textbox(label="Expiry Date", placeholder="YYYY-MM-DD")
                        dosage = gr.Textbox(label="Dosage", placeholder="e.g., 500mg tablets")

                create_btn = gr.Button("üîí Create Quantum-Resistant NFT", variant="primary")

                with gr.Row():
                    nft_output = gr.Textbox(label="NFT Creation Results", lines=10)
                    micro_optics_output = gr.Image(label="Micro-Optics Security Tag", type="pil")

                create_btn.click(
                    create_drug_nft,
                    inputs=[drug_name, manufacturer, batch_number, manufacturing_date, expiry_date, dosage],
                    outputs=[nft_output, micro_optics_output]
                )

            # Tab 2: Drug Verification
            with gr.Tab("üîç Drug Verification"):
                gr.Markdown("### Verify Drug Authenticity with AI Vision")

                with gr.Row():
                    with gr.Column():
                        verify_token_id = gr.Textbox(label="Token ID", placeholder="Enter or scan QR code")
                        user_address = gr.Textbox(label="Your Wallet Address", placeholder="0x...")
                        location = gr.Textbox(label="Location", placeholder="City, Country")

                    with gr.Column():
                        drug_image = gr.Image(label="Upload Drug Photo", type="pil")

                verify_btn = gr.Button("ü§ñ Verify with AI Vision", variant="primary")
                verify_output = gr.Textbox(label="Verification Results", lines=15)

                verify_btn.click(
                    verify_drug_authenticity,
                    inputs=[verify_token_id, user_address, location, drug_image],
                    outputs=verify_output
                )

            # Tab 3: Report Counterfeits
            with gr.Tab("üö® Report Counterfeit"):
                gr.Markdown("### Report Suspected Counterfeit Drugs - Earn Bounty Rewards")

                with gr.Row():
                    with gr.Column():
                        report_token_id = gr.Textbox(label="Token ID (if known)", placeholder="Optional")
                        reporter_address = gr.Textbox(label="Your Wallet Address", placeholder="0x...")
                        report_location = gr.Textbox(label="Location Found", placeholder="City, Country")

                    with gr.Column():
                        evidence_description = gr.Textbox(
                            label="Evidence Description",
                            placeholder="Describe suspicious features, packaging issues, etc.",
                            lines=5
                        )

                report_btn = gr.Button("üí∞ Submit Report & Claim Bounty", variant="secondary")
                report_output = gr.Textbox(label="Report Results", lines=8)

                report_btn.click(
                    report_counterfeit_drug,
                    inputs=[report_token_id, reporter_address, report_location, evidence_description],
                    outputs=report_output
                )

            # Tab 4: User Dashboard
            with gr.Tab("üë§ User Dashboard"):
                gr.Markdown("### Your PharmaChain Activity & Rewards")

                dashboard_address = gr.Textbox(label="Your Wallet Address", placeholder="0x...")
                dashboard_btn = gr.Button("üìä Load Dashboard", variant="primary")
                dashboard_output = gr.Textbox(label="Dashboard", lines=20)

                dashboard_btn.click(
                    get_user_dashboard,
                    inputs=dashboard_address,
                    outputs=dashboard_output
                )

            # Tab 5: Network Statistics
            with gr.Tab("üìà Network Stats"):
                gr.Markdown("### PharmaChain Global Impact Dashboard")

                stats_btn = gr.Button("üåç Load Network Statistics", variant="primary")
                stats_output = gr.Textbox(label="Global Statistics", lines=25)

                stats_btn.click(
                    get_network_statistics,
                    outputs=stats_output
                )

        # Footer
        gr.Markdown("""
        ---
        **üõ°Ô∏è Powered by Quantum-Resistant Blockchain Technology**

        **Tech Stack:** QRL Blockchain ‚Ä¢ Micro-Optics Tags ‚Ä¢ Mobile Vision AI ‚Ä¢ DeFi Incentives

        **Partners:** WHO Collaboration ‚Ä¢ WEF Featured ‚Ä¢ Local Health Ministries

        **Security:** Post-Quantum Cryptography ‚Ä¢ Dilithium Signatures ‚Ä¢ Tamper-Proof Tags
        """)

    return app

# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    # Create and launch the PharmaChain application
    app = create_pharmachain_app()

    # Launch with appropriate settings for Colab
    app.launch(
        share=True,  # Creates public link for sharing
        debug=True,  # Enable debug mode
        server_name="0.0.0.0",  # Allow external connections
        server_port=7860,  # Default Gradio port
        show_error=True  # Show detailed errors
    )

# ============================================================================
# SAMPLE USAGE INSTRUCTIONS
# ============================================================================

"""
To run this PharmaChain prototype in Google Colab:

1. First, install dependencies in a separate cell:
   !pip install gradio pillow opencv-python numpy qrcode[pil]

2. Then run this entire code cell

3. Click the generated public URL to access the application

4. Test the system:
   - Register a new drug in the "Drug Registration" tab
   - Verify drugs using the "Drug Verification" tab
   - Report counterfeits to earn bounties
   - Check your user dashboard and network statistics

If you get import errors, make sure to run the pip install command first!

The system demonstrates:
‚úÖ Quantum-resistant NFT creation
‚úÖ Micro-optics tag generation (with QR codes when available)
‚úÖ AI-powered vision verification
‚úÖ DeFi reward mechanisms
‚úÖ Counterfeit reporting with bounties
‚úÖ Comprehensive user dashboards
‚úÖ Global impact tracking

This prototype simulates the core functionality of a production PharmaChain system
that could save millions of lives by combating counterfeit pharmaceuticals.
"""